package com.by.Zaitsev.Main;

public class Main {

    public static void main(String[] args) {

        Car car1 = new Car("Машина 1", 400);
        Car car2 = new Car("Машина 2", 1000);
        Car car3 = new Car("Машина 3", 2000);
        Car car4 = new Car("Машина 4", 1000);
        Car car5 = new Car("Машина 5", 100);



        try {
            Book myBook1 = new Book("b1", 3000, true);
            Book myBook2 = new Book("b2", 5000, true);
            Book myBook3 = new Book("b3", 3500, false);
            Book myBook4 = new Book("b4", 3000, true);
            Book myBook5 = new Book("b5", 3000, true);

            Library lib = new Library();
            lib.add(myBook1);
            lib.add(myBook2);
            lib.add(myBook3);
            lib.add(myBook4);
            lib.add(myBook5);

            Reader person1 = new Reader(3000, "Serg");
            person1.take(myBook1);
            person1.take(myBook2);
            person1.take(myBook3);
            Reader person2 = new Reader(3000, "Max");
            person2.take(myBook3);
            person2.take(myBook1);
            person2.take(myBook2);
            Reader person3 = new Reader(4000, "Jenya");
            person3.take(myBook4);
            person3.take(myBook3);
            person3.take(myBook2);

            System.out.println("------------- Begin -------------");
            person1.start();
            Thread.sleep(200);
            person2.start();
            Thread.sleep(200);
            person3.start();



            Thread.sleep(20000);
            car1.start();
            car2.start();
            car3.start();
            car4.start();
            car5.start();

        } catch(Exception ex) {
            System.out.println(ex.toString());
        }
    }
}

//Теория

/*
* Каким образом можно создать поток? (Thread или Runnable)
*
* Что такое монитор? (контроль доступа к ресурсу)
*
* Как работают методы wait и notify/notifyAll?
wait(): освобождает монитор и переводит вызывающий поток в состояние ожидания
до тех пор, пока другой поток не вызовет метод notify()
notify(): продолжает работу потока, у которого ранее был вызван метод wait()
notifyAll(): возобновляет работу всех потоков, у которых ранее был вызван метод wait()

* Чем отличается работа метода wait с параметром и без параметра?
final void wait() метод используется в многопоточной среде, может вызываться только потоком,
владеющим объектом синхронизации. При этом объект синхронизации освобождается, а текущий поток
переходит в режим ожидания сигнала освобождения объекта синхронизации другим потоком путем
вызова метода notify() либо notifyAll().
final void wait(long time) аналогично wait(), но ожидание происходит заданное время time,
затем выполнение продолжается безусловно.

* Как работает метод Thread.yield()? Чем отличаются методы Thread.sleep() и Thread.yield()?
yield() пытается сказать планировщику потоков, что нужно выполнить другой поток, что ожидает
в очереди на выполнение. Метод не пытается перевести текущий поток в состояние блокировки, сна или ожидания.
Он просто пытается его перевести из состояние «работающий» в состояние «работоспособный».
Однако выполнение метода может вообще не произвести никакого эффекта. состояние потока остатается RUNNABLE
sleep() приостанавливает поток на указанное. состояние меняется на TIMED_WAITING, по истечению - RUNNABLE
wait() меняет состояние потока на WAITING
может быть вызвано только у объекта владеющего блокировкой, в противном случае выкинется
исключение IllegalMonitorStateException. при срабатывании метода блокировка отпускается,
что позволяет продолжить работу другим потокам ожидающим захватить ту же самую блокировку .
в случае wait(int) с аргументом состояние будет TIMED_WAITING.

* Как работает метод Thread.join()?
Метод join() вызывается для того, чтобы привязать текущий поток в конец потока для которого
вызывается метод. То есть второй поток будет в режиме блокировки пока первый поток не выполнится.

* Что такое dead lock?
Это когда один поток А получил блокировку на объект А1, а поток В получил блокировку на объект В1.
В то время как поток А пытается получит блокировку на объект В1, а поток В на А1.

* Что значит приоритет потока?
Приоритет потока – это число от 1 до 10, в зависимости от которого, планировщик потоков
выбирает какой поток запускать. Однако полагаться на приоритеты для предсказуемого
выполнения многопоточной программы нельзя!

* Что такое потоки - демоны в джава?
Это потоки, которое работают в фоновом режиме и не гарантируют что они завершатся.
Тоеть если все потоки завершились, то поток демон просто обрывается вместе с закрытием приложения.

* Что значит усыпить поток?
Перевести поток в спящее состояние можно с помощью метода sleep(long ms) ms – время в миллисекундах.
При вызове этого метода, поток переходит в спящее состояние, после сна, поток переходит
в пул потоков и находится в состоянии «работоспособный», т.е. не гарантируется что после
пробуждения он будет сразу выполняться. Также поток не может усыпить другой поток,
так как метод sleep – это статический метод! Вы просто усыпите текущий поток и не более того!
Также метод sleep() может возбуждать InterruptedException().

* В каких состояниях может быть поток в джава? Как вообще работает поток?
У нас есть текущий поток, в котором выполняется метод main. Этот поток имеет свой стек и этот стек начинается с вызова метода main.
Далее в методе main мы создаем новый поток, что происходит… создается новый поток и для него выделяется свой стек с первоначальным методом run().

* Различия между CyclicBarrier и CountDownLatch?
Хоть оба эти синхронизаторы позволяют нитям дожидаться друг друга, главное различие между
ними в том, что вы не можете заново использовать CountDownLatch после того, как его счётчик
достигнет нуля, но вы можете использовать CyclicBarrier снова, даже после того, как барьер сломается.

* Как работает Semaphor?
Для управления доступом к ресурсу семафор использует счетчик, представляющий количество разрешений.
Если значение счетчика больше нуля, то поток получает доступ к ресурсу, при этом счетчик уменьшается на единицу.
После окончания работы с ресурсом поток освобождает семафор, и счетчик увеличивается на единицу.
Если же счетчик равен нулю, то поток блокируется и ждет, пока не получит разрешение от семафора.
*/